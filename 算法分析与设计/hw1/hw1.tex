\documentclass[12pt, a4paper, UTF8, fontset=windows]{ctexbook}
\usepackage{amsmath, amsthm, amssymb, amsfonts, bm, color, fancyhdr, framed, geometry, graphicx, hyperref, listings, mathrsfs, xcolor}


\linespread{1.5}
\definecolor{shadecolor}{RGB}{241, 241, 255}
\newcounter{problemname}
\newenvironment{problem}{\begin{shaded}\stepcounter{problemname}\par\noindent\textbf{Q\arabic{problemname}.}}{\end{shaded}\par}
\newenvironment{solution}{\par\noindent\textbf{Ans.}}{\par}


\geometry{left=20mm,right=20mm, top=20mm, bottom=22mm} % 页边距
\setlength{\headheight}{15pt}
\pagestyle{fancy} % 设置页脚页眉
\rhead{Assignment1} % 页眉右边
% \noindent % 取消首段缩进

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
% 代码设置
\lstset{ 
backgroundcolor=\color{white},      % choose the background color
basicstyle=\footnotesize\ttfamily,  % size of fonts used for the code
columns=fullflexible,
tabsize=4,
breaklines=true,               % automatic line breaking only at whitespace
captionpos=b,                  % sets the caption-position to bottom
commentstyle=\color{mygreen},  % comment style
keywordstyle=\color{blue},     % keyword style
stringstyle=\color{mymauve}\ttfamily,  % string literal style
frame=single,
rulesepcolor=\color{red!20!green!20!blue!20},
language=c++,
xleftmargin=3em,
xrightmargin=3em
}

 
\begin{document}

\thispagestyle{empty}

\begin{figure}[t]
    \centering
    \includegraphics[width=6cm]{../src/images/logo.jpg}
\end{figure}

\vspace*{\fill}
    \begin{center}
        \Huge\textbf{Assignment1}
    \end{center}
\vspace*{\fill}

\begin{table}[b]
    \centering
    \large
    \begin{tabular}{ll}
    \textbf{课程:} & 算法设计与分析 \\
    \textbf{姓名:} & 雷翔 \\
    \textbf{学号:} & 2053932 \\
    \textbf{时间:} & 2023年3月 \\
    \end{tabular}
\end{table}


\newpage

\setcounter{page}{1} % 页码从当前页开始

\begin{problem}
    Prove (by using the definitions of the notations involved) or disprove (by giving a specific counterexample)
the following assertions.

    a. If $t(n) \in O(g(n))$, then $g(n) \in \Omega(t(n))$.

    b. $\Theta(\alpha g(n)) = O(g(n))$, where $\alpha > 0$.
    
    c. $\Theta(g(n)) = O(g(n)) \cap \Omega(g(n))$.

    d. For any two nonnegative functions $t(n)$ and $g(n)$ defined on the set of nonnegative \
    intergers, either $t(n) \in O(g(n))$, or $t(n) \in \Omega(g(n))$, or both.
\end{problem}

\begin{solution}

    a. 
    
    正确。因为 $t(n) \in O(g(n))$，所以存在 $c > 0$，$n_0 > 0$，使得当 $ n \ge n_0$ 时，满足 $t(n) \leq c \cdot g(n)$。\ 
    不等式两边同时除以常数c得 $\frac{1}{c} \cdot t(n) \leq g(n)$，即 $k \cdot t(n) \leq g(n)$，其中 $k > 0$，所以 \
    $g(n) \in \Omega(t(n))$。
    \vspace{2mm}  % 指定高度，添加空行
    
    b. 错误。

    令 $\alpha = 1$，即证 $\Theta(g(n)) \neq O(g(n))$。

    取 $f(n) = n$，$g(n) = n^2$。
    
    $O(g(n)) = \{f(n)$:存在 $d_1 > 0$，$n_1 > 0$，使得当 $n > n_1$ 时，满足 $f(n) \le  d_1 g(n)\}$。

    取 $d_1 = 1$，$n_1 = 1$，当 $n \ge n_1$ 时，$n^2 \ge n$，所以 $f(n) \in O(g(n))$。

    $\Theta(g(n)) = \{f(n)$:存在 $c_1 >0$，$c_2 >0$，$n_0 > 0$，使得当 $n \ge n_0$ 时，满足 $c_2 g(n) \le f(n) \le c_1 g(n)\}$。 

    不存在 $c_1 > 0$，$c_2 > 0$，使得 $c_1 n \le n^2 \le c_2 n$ 恒成立，即 $n \notin \Theta(n^2)$。

    所以，$\Theta(g(n)) \neq O(g(n))$。
    \vspace{2mm}  % 指定高度，添加空行

    c. 正确。 

    $O(g(n)) = \{f(n)$:存在 $d_1 > 0$，$n_1 > 0$，使得当 $n > n_1$ 时，满足 $f(n) \le  d_1 g(n)\}$。 

    $\Omega(g(n)) = \{h(n)$:存在 $d_2 > 0$，$n_2 > 0$，使得当 $n > n_2$ 时，满足 $h(n) \ge d_2 g(n)\}$。
    
    所以对 $\forall t(n) \in O(g(n)) \cap \Omega(g(n))$ 当$n \ge \max(n_1, n_2)$ 时，都有 $t(n) \le d_1 g(n)$ 和 $t(n) \ge d_2 g(n)$，\
    即 $d_2 g(n) \le t(n) \le d_1 g(n)$，故 $t(n) \in \Theta(g(n))$。

    同理，$\Theta(g(n)) = \{f(n)$:存在 $c_1 >0$，$c_2 >0$，$n_0 > 0$，使得当 $n \ge n_0$ 时，满足 $c_2 g(n) \le f(n) \le c_1 g(n)\}$。 

    所以对 $\forall t(n) \in \Theta(g(n))$，当 $n \ge n_0$ 时，都有 $c_2 g(n) \le t(n) \le c_1 g(n)$，即 $t(n) \ge c_2 g(n)$ 和 $t(n) \le c_1 g(n)$，故 $t(n) \in O(g(n)) \cap t(n) \in \Omega(g(n))$，\
    即 $t(n) \in O(g(n)) \cap \Omega(g(n))$。
    
    综上，$\Theta(g(n)) = O(g(n)) \cap \Omega(g(n))$。
    \vspace{2mm}  % 指定高度，添加空行

    d. 错误。
\end{solution}


\newpage

\begin{problem}
    Calculate the time complexity of the following algorithms respectively.
    
    a.
    \begin{lstlisting}
    i = 0;
    while ((i + 1) * (i + 1) <= n)
        i = i + 1;
    \end{lstlisting}

    b.
    \begin{lstlisting}
    x = 0;
    for (i = 1; i <= n; i++)
        for (j = 1; j <= i; j++)
            for (k = 1; k <= j; k++)
                x++;
    \end{lstlisting}
\end{problem}

\begin{solution}

    a. 
    
    问题规模： $n$

    基本操作：while语句中的乘法

    执行次数： $M(n) = \lfloor \sqrt{n} \rfloor + 1 ~~~(n \ge 0)$

    时间复杂度： $f(n) \in \Theta(\sqrt{n})$ 
    \vspace{2mm}  % 指定高度，添加空行

    b. 
    
    问题规模： $n$

    基本操作： $x++$

    执行次数： 
    \begin{align*}
        A(n) &= \sum_{i=1}^{n} \sum_{j=1}^{i} \sum_{k=1}^{j} 1 \\
          &= \sum_{i=1}^{n} \sum_{j=1}^{i} j \\
          &= \sum_{i=1}^{n} \frac{1}{2} i (i+1) \\
          &= \frac{1}{6} n (n+1) (n+2)
    \end{align*}

    时间复杂度： $f(n) \in \Theta(n^3)$
\end{solution}

\newpage

\begin{problem}
    Calculate the time complexity of the following recursive algorithms respectively (If it may, the worst, average, and best cases must be investigated separately.)
     
    a.
    \begin{lstlisting}
    int function(int x, int n)
    {
        if (n == 0)
            return 1;
        int t = function(x, n / 2)
        if (n % 2 == 1)
            return t * t * x;
        return t * t;
    }
    \end{lstlisting}

    b.
    \begin{lstlisting}
    void Sort(int A[], int low, int high)
    {
        if (low < high)
        {
            int pivot = Partition(A, low, high);
            Sort(A, low, pivot - 1);
            Sort(A, pivot + 1, high);
        }
    }
    int Partition(int A[], int low, int high)
    {
        int pivot = A[low];
        while (low < high)
        {
            while (low < high && A[high] >= pivot)
                --high;
            A[low] = A[high];
            while (low < high && A[low] <= pivot)
                ++low;
            A[high] = A[low];
        }
        A[low] = pivot;
        return low;
    }
    \end{lstlisting}
\end{problem}
    

\begin{solution}
    
    a. 
    
    问题规模： $n$

    基本操作： $n \% 2 == 1$ 比较

    执行次数： $C(n) = C(n/2) + 1 ~(n \ge 1)$ 和 $C(1) = 1$

    根据平滑性原则，令 $n=2^k$，则有 $C(2^k) = C(2^{k-1}) + 1$，\ 
    $C(2^k) = ··· = C(2^{k-k}) + k = C(1) + k = k + 1$， \
    所以有 $C(2^k) = k + 1$，故 $C(n) = \log_{2}(n) + 1$

    时间复杂度： $function(x, n) \in \Theta(\log_{2}(n))$
    \vspace{2mm}  % 指定高度，添加空行

    b. 
    
    问题规模： $n$

    基本操作：Partition函数中三个while循环中的比较

    执行次数：

    最优情况：每次划分都恰好将数组分成长度相等的子数组 
    
    最坏情况：初始序列有序，每次分割只产生一个子序列

    平均情况：

    时间复杂度：

\end{solution}

\newpage 

\begin{problem}
    Solve the following recurrence relations.
    
    a. $T(n) = T(n-1) + n ~for ~n > 0, T(0) = 1$

    b. $T(n) = 4T(n-1) ~for ~n > 0, T(1) = 5$

    c. $T(n) = T(n/3) + n ~for ~n > 2, T(1) = 1 ~(solve ~for ~n = 3^k)$
\end{problem}


\begin{solution}

    a. 
    \begin{align*}
        T(n) &= T(n-1) + n \\
          &= T(n-2) + (n - 1) + n \\
          &= T(n-3) + (n - 2) + (n -1 ) + n \\
          &= ··· \\
          &= T(0) + 1 + 2 + 3 + ··· + n \\
          &= \frac{n^2 + n + 2}{2} ~(n \ge 0)
    \end{align*}

    $T(n) \in \Theta(n^2)$

    b.
    \begin{align*}
        T(n) &= 4T(n-1) \\
          &= 4 \times 4 T(n-2) \\
          &= ··· \\
          &= 4^{n-1} T(n-1) \\ 
          &= 5 \times 4^{n-1} ~(n \ge 1)
    \end{align*}

    $T(n) \in \Theta(4^n)$

    c.
    令 $n = 3^k$，结合平滑性原则。
    \begin{align*}
        T(3^k) &= T(3^{k-1}) + 3^k \\
          &= T(3^{k-2}) + 3^{k-1} + 3^k \\
          &= T(3^{k-3}) + 3^{k-2} + 3^{k-1} + 3^k \\
          &= ··· \\
          &= T(3^0) + 3^1 + 3^2 + ··· + 3^k \\
          &= 1 + 3^1 + 3^2 + ··· + 3^k \\
          &= \frac{(3^{k+1} - 1)}{2}
    \end{align*}
    
    所以， $T(n) = \frac{(3n-1)}{2} ~(n \ge 1)$

    $T(n) \in \Theta(n)$
\end{solution}

\end{document}